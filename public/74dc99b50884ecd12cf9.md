---
title: テスト理論のパッケージexametrikaを作りました
tags:
  - IRT
  - CRAN
  - exametrika
private: true
updated_at: '2025-11-30T17:22:00+09:00'
id: 74dc99b50884ecd12cf9
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

この記事はRアドカレ2025の4日目の記事です。
`exametrika`というテスト理論のパッケージを開発，CRANに公開しましたので，その宣伝をさせてもらおうとおもいます。あまり細かいパッケージの中身について語るのはRアドカレの趣旨にそぐわないかなと思いますので，パッケージ開発の苦労話と，CRAN登録のノウハウ話を混ぜて書いてみようと思います。


# exametrikaはこんなパッケージ

## 背景

<a href="https://kosugitti.github.io/exametrika/ja.html"><img width="180" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/53345/4f7a6dc7-cf97-4e20-aafd-758127073ce7.png" alt="exametrikaパッケージのアイコン" style="float: right; margin: 0 0 10px 15px;"></a>

exametrikaは，<a href="https://sh0j1ma.stars.ne.jp/">荘島宏二郎先生</a>の開発されたテストデータを分析するいくつものモデルを実行するためのパッケージです。実行できるモデルは8つほどあるのですが，その派生も含めていろいろなオプション・派生があります。

テストデータは反応が0/1，すなわち正答が1で誤答が0になるようなデータです。荘島先生はあくまでも「（学力)テスト」についてのモデルを考えておられますが，開発者の<a href="https://kosugitti.github.io/kosugitti10/">私</a>は心理学が専門ですので，5件法・7件法のような多段階反応を扱いたい。ということで，荘島先生のオリジナルモデルをベースに多段階モデルに拡張したりもしてます。

テスト理論といえば古典的テスト理論とIRT，というイメージかもしれませんが，興味がある人は是非このパッケージ，モデルで遊んでみてください。新しい切り口・アイデアからのモデルがいっぱいあります。また，始祖の設計方針として，「分析して終わり」ではなく，「テストを受けてくれた人に如何に有用な情報を返すか」という点に重点を置き，学習者の学びのルートマップを提供できるように配慮されてます。もちろんテストを実施する人にとっても，項目の情報，構造を考えられるように，いろいろな表現があります。是非ご覧ください。

## exametrikaでできること

このパッケージでできることは大きく分けて，「古典的な手法」「潜在的な構造モデル」「学びのルートモデル」に分かれます。それぞれ簡単に説明しますが，詳しくは<a href="https://kosugitti.github.io/exametrika/ja.html">exametrikaのサイト</a>をご覧ください。

### 古典的な手法

+ テスト統計量・項目統計量の計算
+ 古典的テスト理論；次元解析やアルファ係数なども
+ ロジスティックモデル；1PL,2PL,3PL,4PLモデルに対応。多段階モデルとして段階反応モデルもあります

### 潜在的な構造モデル

項目反応理論のように，能力値$\theta$が小数点下何桁まで必要なシーンばかりではありません。また，$\theta$が0.1増えるとは何がどうなることなのか，よくわからなかったりします。それよりも，学習者の理解の段階にわけてグルーピングする方が有用ではないでしょうか。

+ 潜在クラスモデル；受験者をいくつかのグループにクラスタリングします
+ 潜在ランクモデル；受験者をいくつかの<b>順序づけられた</b>グループ(ランク)にクラスタリングします
+ バイクラスタリングモデル；行(項目)と列(受験者)を，項目はフィールド，受験者はクラスと呼ばれるグループに同時に分類します。
+ ランクラスタリングモデル；バイクラスタリングの受験者クラスが<b>順序づけられた</b>グループ(ランク)に分類します。

バイクラスタリング／ランクラスタリングは，項目のグループと受験者のグループの対応関係が出力されます。クラス／ランクとフィールドとの対応から，次のランクに上がるためには，この領域の問題が解けるようになれば良い，といったことがわかります。

最適なクラス数・ランク数は，AICやBICなどの適合度指標をもとに探索できます。探索用のGridSearch関数もあります。また中華料理店過程を実装した無限関係モデル(Infinite Relational Model)による探索もできます。

またこれらのモデルは多値データにも対応していますので，リッカート法のような心理尺度データも分析できます。

### 学びのルートモデル

ある項目Aが解けたひとが別の項目Bに正答する確率は，条件付き確率で表現できます。正答率の順に並べることで，学びのルートが見えてきますね。この条件付き確率のグラフ表現である，ベイジアンネットワークモデルをテストデータに応用できます。

+ ベイジアンネットワークモデル；ベイジアンネットワークモデルは、項目の正答率に基づいて、項目間の条件付き確率をネットワーク形式で表現するモデルです。項目間の有向非循環グラフ（DAG）を外部から与えることで、指定されたグラフに基づいて条件付き確率を計算します。
+ 局所依存潜在ランク分析；潜在ランク内の項目間のネットワーク構造を分析するために使用されます。
+ 局所依存バイクラスタリング；バイクラスタリングとベイジアンネットワークモデルを組み合わせたものです。
+ バイクラスターネットワークモデル；ベイジアンネットワークモデルとバイクラスタリングを組み合わせたモデルです。

これらのモデルは，項目間・フィールド間のネットワークモデルを外部から与える必要がありますが，データから探索的に見つけることもできます。遺伝的アルゴリズムを用いて，データから変数間のネットワークモデルを自動的に生成・分析できます。

これらのモデルの詳細は，荘島先生のテキスト<a href="https://amzn.to/3XtC0si">Test Data Engineering</a>をごらんください。また，パッケージの使い方については，<a href="https://kosugitti.github.io/slides/BMS2025spring/docs/">日本語での解説ページ</a>もありますのでご参考までに。

# パッケージ開発のお話

さて，パッケージの宣伝はここまでにして，少しブログっぽい記事を。
そもそもexametrikaは，荘島先生ご自身の手によって<a href="https://sh0j1ma.stars.ne.jp/tde/index.htm">MathematicaのソースとExcelのマクロ</a>が公開されてるんですよね。

一部のモデルがExcelでも実行できるのは，テストを現場の先生が分析するときに専門のソフトを買ったり導入したりできないでしょ，というご配慮からのものだそうです。複雑なモデルはMathematicaで公開されてて。ところが私の第一使用言語はRなのでねー。Rに移植したい，移植中にアルゴリズムも勉強しちゃえ，というモチベで始まりました。

開発が始まったのが2年前。当時はまだそれほど賢くなかった生成AIでしたが，言語間の翻訳はまあまあできたので，Mathematicaのソースコードを与えては，「これは何をやってるの」を聞きながらの移植でした。Mathematicaの「全部リストでやる」あたりと，Transpose関数の使い方とかがRの直感的なそれとは違ったので苦労したなあ。

当時の生成AIの賢さでも，書き上がったものを清書するとか，効率化するのはそこそこ上手く行きました。ついでに言うと，私は英語が下手くそだし，マニュアルとか書くのも嫌なんだけど，その辺を生成AIに頼れるのは助かりました。当時はCLIがなかったので，アプリからのコピペが大変でしたが。今はClaude CLIと一緒に変数名の統一とか，サンプルデータを生成させてテストするなんてのもできますから，パッケージ開発の敷居がぐっと下がった感があります。

開発しながら，Rにおけるクラスの継承[^1]とか，セマンティックバージョニング[^2]とか，ジェネリック関数[^3]のテクニックとか，今まで考えたこともなかったようなことについても学びました。なるほど，こういう仕組みになってるのか・・・と言うことがいっぱいです。今，「こいつはなんのことを言ってるんだ」と思った人は，ぜひこれらのキーワードで調べてみてください。Rの世界はよくできてて，広大で，面白いです(一応脚注に私なりの答えを書いておきます)。

唯一困ったのが，Mathematicaと比べて数値的な精度が出ないこと！今回はMathematica版という「正解」があるわけですから，`testthat`を使って検算したりバグが出ないかチェックする体制も整えているんだけど，最適化関数などで「これは言語による違いとしか・・・」みたいな壁が出ました[^4]。まあある程度は仕方ないですね。速度も出ないことがあって，`GRM`関数なんかはもう全然理論通りにいかないの。今は生成AIの力を借りて，一部C言語で書いたのを`Rcpp`から使ったりして，精度・速度ともに向上しましたが，開発時はそんな苦労がありました。

でも使い慣れたRで書けることは，何より幸せなことでした！

## 野良パッケージからCRANへ

最初はGithubで開発してて，GitHub Pagesで公開もしてて，これで十分だと思っていました。作業のログと随時公開でいいじゃないかと。しかしまあ，人間欲がでてくるもので。徐々にCRANに登録したくなってきました。別件で，生成AIのセミナーに参加してた時に，「これだけ翻訳したり指示で動いてくれたりするんなら，外国語も怖くないな」と思ったのがきっかけ。ちょうど学会のセミナーでこのパッケージを使うことにしたころで，初心者に`devtools`パッケージを使わせるよりも，`install.packages`関数で導入できた方がいいかなと思ったというのもあります。

ということで，再び生成AIに英会話を助けてもらいながら，CRANにチャレンジ。
結果から言うと，思い立ってから2週間ほどで投稿できました。この辺りの話は，<a href="https://speakerdeck.com/kosugitti/cranhenodao">研究会発表資料</a>や<a href = "https://note.com/kosugitti/n/nee089418a582">NOTE</a>にも書いたので，興味があればご笑覧ください。

いずれにせよ，RStudioや`devtools`,`usethis`パッケージなど開発環境がかなり後押ししてくれるし，わからないことがあれば生成AIに聞けばいいということで，かなり不安感や壁の高さから解放されながらパッケージ開発，CRAN登録ができました。生成AIは偉大ですね。皆さん，もう怖がらなくて良くなりましたよ！

ちなみに，皆さんご承知の通り，CRANに載せるには査読があります。あれこれ直しなさいと言われるけど，言われた問題を直せば掲載してくれるのは，論文を投稿するのと同じイメージ。論文と違うのは，通れば終わりじゃないというか，そこからがメンテナンスなど，使ってもらえるかどうかの本番が始まるというところでしょうか。ただ，一度通ると，その後のアップデートはチェックが格段にゆるいです。もちろん投稿前の一通りのチェックはしてから，`devtools::release()`をするんだけど，朝だして午後にはCRANで公開されてる，という感じです。NEWS.mdを書いたりするのも生成AIと一緒にやってます。だから気軽に修正したり，アップデートしたりします。保守管理が比較的簡単にできるのもいいところかなと思います。
今の`exametrika`は1.7.0ですが，1.8.0も準備中。サンデープログラマとして，趣味的にコツコツと機能を増やしていきます。

皆さんも，パッケージ開発を楽しんでみてはいかがでしょうか。Enjoy〜！

---

P.S. `exametrika`パッケージについて何かご意見，ご要望があれば，<a href="https://kosugitti.github.io/exametrika/">Github</a>からご連絡ください。


[^1]: printやplotなど，Rの持ってる出力関数を引き継いで，独自のクラスの振る舞いをさせることができます。exametrikaは内部でexametrikaクラスを作っていて，`print.exametrika`を定義すると`print(exametrikaオブジェクト)`とするだけで自分の書いた出力フォームで出力させられます。最初クラスを作っただけで中のコードを書いてなかったら，`print`としても何も出力されなくて(継承したけどやることが書いてない)焦ったのは良い思い出。
[^2]: バージョンの数字の付け方も，最初はあんまりわかってなくて，大きいのが一桁目，ちょっと変えたぐらいなら三桁目，まあまあなら二桁目を変えるんかなあ，と言うぐらいの理解でした。Major.Minor.PatchがAPIの互換性の有無，後方互換性の有無，バグフィックスくらいの違い，という基準があるんですねえ。勉強になったわ。
[^3]: ジェネリックって何？後発のメーカーのこと？ぐらいの理解だったんですが，関数を生む関数みたいなもんですな。`exametrika`はバイナリデータでも順序データでもいいんですが，データの種類が変わるたびに関数名が変わる(`LRA_binary()`,`LRA_ordinal()`とか？)のはユーザにとってわかりにくいですよね。どちらも`LRA`で，データの型に応じて自動的に変わってほしい。これをやってくれるのがジェネリック関数の発想で，`UseMethod`という関数で分岐させるのです。まず`LRA<- function(U,...){UseMethod("LRA")}`のようにします。次に`LRA.default`という最初に通る関数を書いて，あとはこの関数の内部で状況に応じて別の関数に分岐させる方法。すばらしい。(このやり方はClaudeに教えてもらいました。自分の頭の中からは出てこなかった！)
[^4]: この問題に直面したのは最尤法でポリコリック相関係数を算出するときでした。つまり，開発のごく初期なんですな(笑)結局，ここだけテストの通過基準を緩めました（小数点下3桁まであってたらOK,ぐらいにした。他は下7桁ぐらいまで合致するような基準にしてます)
